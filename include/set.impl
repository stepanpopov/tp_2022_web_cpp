#include "set.h"

namespace tp {
    template<class T>
    set<T>::set() : root_(nullptr),
                    begin_(nullptr),
                    end_(new node<T>),
                    size_(0) {}

    template<class T>
    set<T>::set(const std::initializer_list<T> &init_list) : set() {
        for (typename std::initializer_list<T>::const_iterator it =
                init_list.begin(); it != init_list.end(); it++) {
            insert(*it);
        }
    }

    template<class T>
    template<class Input_iterator>
    constexpr set<T>::set(const Input_iterator it_first, const Input_iterator it_last) : set() {
        for (Input_iterator it = it_first; it != it_last; std::advance(it, 1)) {
            insert(*it);
        }
    }

    template<class T>
    set<T>::set(const set <T> &s) : set() {
        node_visit_and_copy(root_, s.root_);
        tie_linked_list();
        size_ = s.size_;
    }

    template<class T>
    set <T> &set<T>::operator=(const set <T> &s) {
        node_visit_and_delete(root_);
        root_ = nullptr;
        begin_ = nullptr;
        end_->prev = nullptr;

        node_visit_and_copy(root_, s.root_);
        tie_linked_list();
        size_ = s.size_;

        return *this;
    }

    template<class T>
    set<T>::~set() {
        delete end_;
        node_visit_and_delete(root_);
    }

// SET METHODS
    template<class T>
    void set<T>::insert(const T &key) {
        if (!node_find(root_, key)) {
            root_ = node_insert(root_, key);
            size_++;
            tie_linked_list();
        }
    }

    template<class T>
    void set<T>::erase(const T &key) {
        if (node_find(root_, key)) {
            root_ = node_remove(root_, key);
            size_--;
            tie_linked_list();
        }
    }

    template<class T>
    void set<T>::tie_linked_list() {
        node<T> *node_prev = nullptr;
        linked_list_tier(root_, node_prev);
    }

    template<class T>
    void set<T>::linked_list_tier(node <T> *n,
                                  node <T> *&node_prev) {
        if (n == nullptr) {
            return;
        }
        linked_list_tier(n->left, node_prev);

        if (node_prev == nullptr) {
            begin_ = n;
            n->prev = nullptr;
        } else {
            node_prev->next = n;
            n->prev = node_prev;
        }
        n->next = end_;  // end ties here
        end_->prev = n;
        node_prev = n;

        linked_list_tier(n->right, node_prev);
    }

    template<class T>
    size_t set<T>::size() const {
        return size_;
    }

    template<class T>
    bool set<T>::empty() const {
        return (size_ == 0);
    }


// AVL TREE

    template<class T>
    void set<T>::node_visit_and_delete(node <T> *n) {
        if (n == nullptr) {
            return;
        }
        node_visit_and_delete(n->left);
        node_visit_and_delete(n->right);

        delete n;
    }

    template<class T>
    void set<T>::node_visit_and_copy(node <T> *&n, node <T> *copy_node) {
        if (copy_node == nullptr) {
            return;
        }
        n = new node<T>(copy_node->key);

        node_visit_and_copy(n->left, copy_node->left);
        node_visit_and_copy(n->right, copy_node->right);
    }

    template<class T>
    bool set<T>::node_find(node <T> *n, const T &key) const {
        if (n == nullptr) {
            return false;
        }
        if (n->key == key) {
            return true;
        }

        if (n->key > key) {
            return node_find(n->left, key);
        } else {
            return node_find(n->right, key);
        }
    }

    template<class T>
    node <T> *set<T>::node_insert(node <T> *n, const T &key) {
        if (n == nullptr) {
            return new node<T>(key);
        }

        if (n->key > key) {
            n->left = node_insert(n->left, key);
        } else if (n->key < key) {
            n->right = node_insert(n->right, key);
        }

        return node_balance(n);
    }

    template<class T>
    node <T> *set<T>::node_find_min(node <T> *n) const {  // node_remove helper
        if (n->left == nullptr) {
            return n;
        }
        return node_find_min(n->left);
    }

    template<class T>
    node <T> *set<T>::node_without_min(node <T> *n) {  // node_remove helper
        if (n->left == nullptr) {
            return n->right;
        }
        n->left = node_without_min(n->left);
        return node_balance(n);
    }

    template<class T>
    node <T> *set<T>::node_remove(node <T> *n, const T &key) {
        if (n == nullptr) {
            return nullptr;
        }
        if (n->key > key) {
            n->left = node_remove(n->left, key);
        } else if (n->key < key) {
            n->right = node_remove(n->right, key);
        } else if (n->key == key) {
            node<T> *node_left = n->left;
            node<T> *node_right = n->right;
            delete n;

            if (node_right == nullptr) {
                return node_left;
            }

            node<T> *node_min = node_find_min(node_right);
            node_min->right = node_without_min(node_right);
            node_min->left = node_left;

            return node_balance(node_min);
        }

        return node_balance(n);
    }

// AVL TREE BALANCE

    template<class T>
    size_t set<T>::node_height(node <T> *n) const {
        if (n != nullptr) {
            return n->height;
        } else {
            return 0;
        }
    }

    template<class T>
    int set<T>::node_balance_factor(node <T> *n) const {
        return node_height(n->right) - node_height(n->left);
    }

    template<class T>
    void set<T>::node_fix_height(node <T> *n) {
        size_t height_left = node_height(n->left);
        size_t height_right = node_height(n->right);

        n->height = std::max(height_left, height_right) + 1;
    }

    template<class T>
    node <T> *set<T>::node_rotate_right(node <T> *n) {
        node<T> *q = n->left;
        n->left = q->right;
        q->right = n;
        node_fix_height(n);
        node_fix_height(q);
        return q;
    }

    template<class T>
    node <T> *set<T>::node_rotate_left(node <T> *n) {
        node<T> *p = n->right;
        n->right = p->left;
        p->left = n;
        node_fix_height(n);
        node_fix_height(p);
        return p;
    }

    template<class T>
    node <T> *set<T>::node_balance(node <T> *n) {
        node_fix_height(n);
        if (node_balance_factor(n) == 2 && node_balance_factor(n->right) < 0) {
            n->right = node_rotate_right(n->right);
            return node_rotate_left(n);
        } else if (node_balance_factor(n) == 2 && node_balance_factor(n->right) >= 0) {
            return node_rotate_left(n);
        } else if (node_balance_factor(n) == -2 && node_balance_factor(n->left) > 0) {
            n->left = node_rotate_left(n->left);
            return node_rotate_right(n);
        } else if (node_balance_factor(n) == -2 && node_balance_factor(n->left) <= 0) {
            return node_rotate_right(n);
        }
        return n;
    }

}  // namespace tp
